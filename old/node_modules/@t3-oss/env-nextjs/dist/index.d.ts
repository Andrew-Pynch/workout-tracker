import * as zod from 'zod';
import { ZodType, ZodError } from 'zod';

type ErrorMessage<T extends string> = T;
type Impossible<T extends Record<string, any>> = Partial<Record<keyof T, never>>;
interface BaseOptions<TShared extends Record<string, ZodType>> {
    isServer?: boolean;
    shared?: TShared;
    onValidationError?: (error: ZodError) => never;
    onInvalidAccess?: (variable: string) => never;
    skipValidation?: boolean;
}
interface StrictOptions<TPrefix extends string, TServer extends Record<string, ZodType>, TClient extends Record<string, ZodType>, TShared extends Record<string, ZodType>> extends BaseOptions<TShared> {
    runtimeEnvStrict: Record<{
        [TKey in keyof TClient]: TKey extends `${TPrefix}${string}` ? TKey : never;
    }[keyof TClient] | {
        [TKey in keyof TServer]: TKey extends `${TPrefix}${string}` ? never : TKey;
    }[keyof TServer] | {
        [TKey in keyof TShared]: TKey extends string ? TKey : never;
    }[keyof TShared], string | boolean | number | undefined>;
    runtimeEnv?: never;
}
interface ClientOptions<TPrefix extends string, TClient extends Record<string, ZodType>> {
    clientPrefix: TPrefix;
    client: Partial<{
        [TKey in keyof TClient]: TKey extends `${TPrefix}${string}` ? TClient[TKey] : ErrorMessage<`${TKey extends string ? TKey : never} is not prefixed with ${TPrefix}.`>;
    }>;
}
interface ServerOptions<TPrefix extends string, TServer extends Record<string, ZodType>> {
    server: Partial<{
        [TKey in keyof TServer]: TPrefix extends "" ? TServer[TKey] : TKey extends `${TPrefix}${string}` ? ErrorMessage<`${TKey extends `${TPrefix}${string}` ? TKey : never} should not prefixed with ${TPrefix}.`> : TServer[TKey];
    }>;
}
type ServerClientOptions<TPrefix extends string, TServer extends Record<string, ZodType>, TClient extends Record<string, ZodType>> = (ClientOptions<TPrefix, TClient> & ServerOptions<TPrefix, TServer>) | (ServerOptions<TPrefix, TServer> & Impossible<ClientOptions<never, never>>) | (ClientOptions<TPrefix, TClient> & Impossible<ServerOptions<never, never>>);

declare const CLIENT_PREFIX: "NEXT_PUBLIC_";
type ClientPrefix = typeof CLIENT_PREFIX;
type Options<TServer extends Record<string, ZodType>, TClient extends Record<`${ClientPrefix}${string}`, ZodType>, TShared extends Record<string, ZodType>> = Omit<StrictOptions<ClientPrefix, TServer, TClient, TShared> & ServerClientOptions<ClientPrefix, TServer, TClient>, "runtimeEnvStrict" | "runtimeEnv" | "clientPrefix"> & ({
    runtimeEnv: StrictOptions<ClientPrefix, TServer, TClient, TShared>["runtimeEnvStrict"];
    experimental__runtimeEnv?: never;
} | {
    runtimeEnv?: never;
    experimental__runtimeEnv: Record<{
        [TKey in keyof TClient]: TKey extends `${ClientPrefix}${string}` ? TKey : never;
    }[keyof TClient] | {
        [TKey in keyof TShared]: TKey extends string ? TKey : never;
    }[keyof TShared], string | boolean | number | undefined>;
});
declare function createEnv<TServer extends Record<string, ZodType> = NonNullable<unknown>, TClient extends Record<`${ClientPrefix}${string}`, ZodType> = NonNullable<unknown>, TShared extends Record<string, ZodType> = NonNullable<unknown>>(opts: Options<TServer, TClient, TShared>): Readonly<(zod.objectUtil.addQuestionMarks<{ [k_1 in keyof TServer]: TServer[k_1]["_output"]; }> extends infer T_4 extends object ? { [k in keyof T_4]: zod.objectUtil.addQuestionMarks<{ [k_1 in keyof TServer]: TServer[k_1]["_output"]; }>[k]; } : never) & (zod.objectUtil.addQuestionMarks<{ [k_2 in keyof TClient]: TClient[k_2]["_output"]; }> extends infer T_5 extends object ? { [k_1 in keyof T_5]: zod.objectUtil.addQuestionMarks<{ [k_2 in keyof TClient]: TClient[k_2]["_output"]; }>[k_1]; } : never) & (zod.objectUtil.addQuestionMarks<{ [k_4 in keyof TShared]: TShared[k_4]["_output"]; }> extends infer T_6 extends object ? { [k_3 in keyof T_6]: zod.objectUtil.addQuestionMarks<{ [k_4 in keyof TShared]: TShared[k_4]["_output"]; }>[k_3]; } : never) extends infer T ? { [P in keyof T]: ((zod.objectUtil.addQuestionMarks<{ [k_1 in keyof TServer]: TServer[k_1]["_output"]; }> extends infer T_1 extends object ? { [k in keyof T_1]: zod.objectUtil.addQuestionMarks<{ [k_1 in keyof TServer]: TServer[k_1]["_output"]; }>[k]; } : never) & (zod.objectUtil.addQuestionMarks<{ [k_2 in keyof TClient]: TClient[k_2]["_output"]; }> extends infer T_2 extends object ? { [k_1 in keyof T_2]: zod.objectUtil.addQuestionMarks<{ [k_2 in keyof TClient]: TClient[k_2]["_output"]; }>[k_1]; } : never) & (zod.objectUtil.addQuestionMarks<{ [k_4 in keyof TShared]: TShared[k_4]["_output"]; }> extends infer T_3 extends object ? { [k_3 in keyof T_3]: zod.objectUtil.addQuestionMarks<{ [k_4 in keyof TShared]: TShared[k_4]["_output"]; }>[k_3]; } : never))[P]; } : never>;

export { createEnv };
