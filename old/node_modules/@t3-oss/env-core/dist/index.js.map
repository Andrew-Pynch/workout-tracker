{"version":3,"sources":["../index.ts"],"names":["z","createEnv","opts","runtimeEnv","_client","_server","_shared","client","server","shared","isServer","allClient","allServer","parsed","onValidationError","error","onInvalidAccess","_variable","target","prop"],"mappings":"AAAA,OAAS,KAAAA,MAAsD,MAgJxD,SAASC,EAMdC,EAOA,CACA,IAAMC,EAAaD,EAAK,kBAAoBA,EAAK,YAAc,QAAQ,IAIvE,GAFa,CAAC,CAACA,EAAK,eAEV,OAAOC,EAEjB,IAAMC,EAAU,OAAOF,EAAK,QAAW,SAAWA,EAAK,OAAS,CAAC,EAC3DG,EAAU,OAAOH,EAAK,QAAW,SAAWA,EAAK,OAAS,CAAC,EAC3DI,EAAU,OAAOJ,EAAK,QAAW,SAAWA,EAAK,OAAS,CAAC,EAC3DK,EAASP,EAAE,OAAOI,CAAO,EACzBI,EAASR,EAAE,OAAOK,CAAO,EACzBI,EAAST,EAAE,OAAOM,CAAO,EACzBI,EAAWR,EAAK,UAAY,OAAO,OAAW,IAE9CS,EAAYJ,EAAO,MAAME,CAAM,EAC/BG,EAAYJ,EAAO,MAAMC,CAAM,EAAE,MAAMF,CAAM,EAC7CM,EAASH,EACXE,EAAU,UAAUT,CAAU,EAC9BQ,EAAU,UAAUR,CAAU,EAE5BW,EACJZ,EAAK,oBACHa,GAAoB,CACpB,cAAQ,MACN,wCACAA,EAAM,QAAQ,EAAE,WAClB,EACM,IAAI,MAAM,+BAA+B,CACjD,GAEIC,EACJd,EAAK,kBACHe,GAAsB,CACtB,MAAM,IAAI,MACR,6EACF,CACF,GAEF,OAAIJ,EAAO,UAAY,GACdC,EAAkBD,EAAO,KAAK,EAG3B,IAAI,MAAMA,EAAO,KAAM,CACjC,IAAIK,EAAQC,EAAM,CAChB,GAAI,OAAOA,GAAS,SACpB,MACE,CAACT,GACDR,EAAK,cACL,CAACiB,EAAK,WAAWjB,EAAK,YAAY,GAClCO,EAAO,MAAMU,CAAiC,IAAM,OAE7CH,EAAgBG,CAAI,EAEtBD,EAAOC,CAA2B,CAC3C,CAWF,CAAC,CAIH","sourcesContent":["import { z, type ZodError, type ZodObject, type ZodType } from \"zod\";\n\nexport type ErrorMessage<T extends string> = T;\nexport type Simplify<T> = {\n  [P in keyof T]: T[P];\n  // eslint-disable-next-line @typescript-eslint/ban-types\n} & {};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Impossible<T extends Record<string, any>> = Partial<\n  Record<keyof T, never>\n>;\n\nexport interface BaseOptions<TShared extends Record<string, ZodType>> {\n  /**\n   * How to determine whether the app is running on the server or the client.\n   * @default typeof window === \"undefined\"\n   */\n  isServer?: boolean;\n\n  /**\n   * Shared variables, often those that are provided by build tools and is available to both client and server,\n   * but isn't prefixed and doesn't require to be manually supplied. For example `NODE_ENV`, `VERCEL_URL` etc.\n   */\n  shared?: TShared;\n\n  /**\n   * Called when validation fails. By default the error is logged,\n   * and an error is thrown telling what environment variables are invalid.\n   */\n  onValidationError?: (error: ZodError) => never;\n\n  /**\n   * Called when a server-side environment variable is accessed on the client.\n   * By default an error is thrown.\n   */\n  onInvalidAccess?: (variable: string) => never;\n\n  /**\n   * Whether to skip validation of environment variables.\n   * @default false\n   */\n  skipValidation?: boolean;\n}\n\nexport interface LooseOptions<TShared extends Record<string, ZodType>>\n  extends BaseOptions<TShared> {\n  runtimeEnvStrict?: never;\n  /**\n   * Runtime Environment variables to use for validation - `process.env`, `import.meta.env` or similar.\n   * Unlike `runtimeEnvStrict`, this doesn't enforce that all environment variables are set.\n   */\n  runtimeEnv: Record<string, string | boolean | number | undefined>;\n}\n\nexport interface StrictOptions<\n  TPrefix extends string,\n  TServer extends Record<string, ZodType>,\n  TClient extends Record<string, ZodType>,\n  TShared extends Record<string, ZodType>\n> extends BaseOptions<TShared> {\n  /**\n   * Runtime Environment variables to use for validation - `process.env`, `import.meta.env` or similar.\n   * Enforces all environment variables to be set. Required in for example Next.js Edge and Client runtimes.\n   */\n  runtimeEnvStrict: Record<\n    | {\n        [TKey in keyof TClient]: TKey extends `${TPrefix}${string}`\n          ? TKey\n          : never;\n      }[keyof TClient]\n    | {\n        [TKey in keyof TServer]: TKey extends `${TPrefix}${string}`\n          ? never\n          : TKey;\n      }[keyof TServer]\n    | {\n        [TKey in keyof TShared]: TKey extends string ? TKey : never;\n      }[keyof TShared],\n    string | boolean | number | undefined\n  >;\n  runtimeEnv?: never;\n}\n\nexport interface ClientOptions<\n  TPrefix extends string,\n  TClient extends Record<string, ZodType>\n> {\n  /**\n   * Client-side environment variables are exposed to the client by default. Set what prefix they have\n   */\n  clientPrefix: TPrefix;\n\n  /**\n   * Specify your client-side environment variables schema here. This way you can ensure the app isn't\n   * built with invalid env vars. To expose them to the client, prefix them with `NEXT_PUBLIC_`.\n   */\n  client: Partial<{\n    [TKey in keyof TClient]: TKey extends `${TPrefix}${string}`\n      ? TClient[TKey]\n      : ErrorMessage<`${TKey extends string\n          ? TKey\n          : never} is not prefixed with ${TPrefix}.`>;\n  }>;\n}\n\nexport interface ServerOptions<\n  TPrefix extends string,\n  TServer extends Record<string, ZodType>\n> {\n  /**\n   * Specify your server-side environment variables schema here. This way you can ensure the app isn't\n   * built with invalid env vars.\n   */\n  server: Partial<{\n    [TKey in keyof TServer]: TPrefix extends \"\"\n      ? TServer[TKey]\n      : TKey extends `${TPrefix}${string}`\n      ? ErrorMessage<`${TKey extends `${TPrefix}${string}`\n          ? TKey\n          : never} should not prefixed with ${TPrefix}.`>\n      : TServer[TKey];\n  }>;\n}\n\nexport type ServerClientOptions<\n  TPrefix extends string,\n  TServer extends Record<string, ZodType>,\n  TClient extends Record<string, ZodType>\n> =\n  | (ClientOptions<TPrefix, TClient> & ServerOptions<TPrefix, TServer>)\n  | (ServerOptions<TPrefix, TServer> & Impossible<ClientOptions<never, never>>)\n  | (ClientOptions<TPrefix, TClient> & Impossible<ServerOptions<never, never>>);\n\nexport type EnvOptions<\n  TPrefix extends string,\n  TServer extends Record<string, ZodType>,\n  TClient extends Record<string, ZodType>,\n  TShared extends Record<string, ZodType>\n> =\n  | (LooseOptions<TShared> & ServerClientOptions<TPrefix, TServer, TClient>)\n  | (StrictOptions<TPrefix, TServer, TClient, TShared> &\n      ServerClientOptions<TPrefix, TServer, TClient>);\n\nexport function createEnv<\n  TPrefix extends string = \"\",\n  TServer extends Record<string, ZodType> = NonNullable<unknown>,\n  TClient extends Record<string, ZodType> = NonNullable<unknown>,\n  TShared extends Record<string, ZodType> = NonNullable<unknown>\n>(\n  opts: EnvOptions<TPrefix, TServer, TClient, TShared>\n): Readonly<\n  Simplify<\n    z.infer<ZodObject<TServer>> &\n      z.infer<ZodObject<TClient>> &\n      z.infer<ZodObject<TShared>>\n  >\n> {\n  const runtimeEnv = opts.runtimeEnvStrict ?? opts.runtimeEnv ?? process.env;\n\n  const skip = !!opts.skipValidation;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-explicit-any\n  if (skip) return runtimeEnv as any;\n\n  const _client = typeof opts.client === \"object\" ? opts.client : {};\n  const _server = typeof opts.server === \"object\" ? opts.server : {};\n  const _shared = typeof opts.shared === \"object\" ? opts.shared : {};\n  const client = z.object(_client);\n  const server = z.object(_server);\n  const shared = z.object(_shared);\n  const isServer = opts.isServer ?? typeof window === \"undefined\";\n\n  const allClient = client.merge(shared);\n  const allServer = server.merge(shared).merge(client);\n  const parsed = isServer\n    ? allServer.safeParse(runtimeEnv) // on server we can validate all env vars\n    : allClient.safeParse(runtimeEnv); // on client we can only validate the ones that are exposed\n\n  const onValidationError =\n    opts.onValidationError ??\n    ((error: ZodError) => {\n      console.error(\n        \"❌ Invalid environment variables:\",\n        error.flatten().fieldErrors\n      );\n      throw new Error(\"Invalid environment variables\");\n    });\n\n  const onInvalidAccess =\n    opts.onInvalidAccess ??\n    ((_variable: string) => {\n      throw new Error(\n        \"❌ Attempted to access a server-side environment variable on the client\"\n      );\n    });\n\n  if (parsed.success === false) {\n    return onValidationError(parsed.error);\n  }\n\n  const env = new Proxy(parsed.data, {\n    get(target, prop) {\n      if (typeof prop !== \"string\") return undefined;\n      if (\n        !isServer &&\n        opts.clientPrefix &&\n        !prop.startsWith(opts.clientPrefix) &&\n        shared.shape[prop as keyof typeof shared.shape] === undefined\n      ) {\n        return onInvalidAccess(prop);\n      }\n      return target[prop as keyof typeof target];\n    },\n    // Maybe reconsider this in the future:\n    // https://github.com/t3-oss/t3-env/pull/111#issuecomment-1682931526\n    // set(_target, prop) {\n    //   // Readonly - this is the error message you get from assigning to a frozen object\n    //   throw new Error(\n    //     typeof prop === \"string\"\n    //       ? `Cannot assign to read only property ${prop} of object #<Object>`\n    //       : `Cannot assign to read only property of object #<Object>`\n    //   );\n    // },\n  });\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-explicit-any\n  return env as any;\n}\n"]}